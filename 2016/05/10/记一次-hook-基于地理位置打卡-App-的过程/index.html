<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 记一次 hook 基于地理位置打卡 App 的过程 · 一路小跑</title><meta name="description" content="记一次 hook 基于地理位置打卡 App 的过程 - jk.yeo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jkyeo.com/atom.xml" title="一路小跑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="https://github.com/jkyeo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/Link/" target="_self" class="nav-list-link">LINK</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">记一次 hook 基于地理位置打卡 App 的过程</h1><div class="post-info">May 10, 2016</div><div class="post-content"><blockquote>
<p>有些事我都已忘记<br>但我现在还记得<br>在一个晚上我的母亲问我<br>今天怎么不开心<br>我说在我的想象中。。。我下班忘记打卡了</p>
</blockquote>
<a id="more"></a>
<h2 id="u8001_u677F_uFF0C_u6211_u53EF_u4EE5_u5728_u5BB6_u6253_u5361_u5417_uFF1F"><a href="#u8001_u677F_uFF0C_u6211_u53EF_u4EE5_u5728_u5BB6_u6253_u5361_u5417_uFF1F" class="headerlink" title="老板，我可以在家打卡吗？"></a>老板，我可以在家打卡吗？</h2><p>手机打卡 App 是基于地理位置实现的，原理简单的说就是 App 通过定位获取当前经纬度，再根据目标经纬度（公司办公点）计算出两点直线距离。如果距离低于一个特定的阈值，即可向服务器发送 request 打卡。另外，结合目标经纬度计算距离的操作是在服务器完成的。</p>
<p>实现远程打卡我想到的有两个思路：</p>
<ul>
<li>1.中间人攻击，抓打卡数据包，篡改经纬度等关键数据，再发送给服务器。</li>
<li>2.在 App 端 hook 获取经纬度的方法，返回虚假经纬度。</li>
</ul>
<h2 id="u4E2D_u95F4_u4EBA_u653B_u51FB"><a href="#u4E2D_u95F4_u4EBA_u653B_u51FB" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>首先使用的是 <a href="https://www.charlesproxy.com" target="_blank" rel="external">Chales</a> 做实验，发现使用了 https 协议，不错！有安全意识。配置 Chales 证书之后就能看到数据包了。然后打断点编辑再传就随便啦。<br>这个方法需要借助工具，且操作较为复杂。很难保证与其他埋点数据保持一致。在只有手机设备的情况下比较难实施。还是在源头上 hook 数据比较好。</p>
<h2 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h2><p>在 Android 里说道 hook 就不得不提 Xposed 了:</p>
<blockquote>
<p>Xposed is a framework for modules that can change the behavior of the system and apps without touching any APKs. That’s great because it means that modules can work for different versions and even ROMs without any changes (as long as the original code was not changed too much). It’s also easy to undo. As all changes are done in the memory, you just need to deactivate the module and reboot to get your original system back. There are many other advantages, but here is just one more: Multiple modules can do changes to the same part of the system or app. With modified APKs, you to decide for one. No way to combine them, unless the author builds multiple APKs with different combinations.</p>
</blockquote>
<p>“change the behavior”, “without touching any APKs” 这两点就够兴奋的了。</p>
<p>首先下载打卡 app android apk 文件，使用 <a href="https://github.com/skylot/jadx" target="_blank" rel="external">jadx</a> 尝试反编译，拿到打卡入口。不错，没加壳没混淆。这一步很轻松。</p>
<p>这里通过资源定位逻辑方法：通过打卡按钮点击事件查找到调用方法：hitCard(). 没错，命名就是 hitCard, 真是通俗易懂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 打卡方法</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> longitude 经度</div><div class="line">* <span class="doctag">@param</span> latitude 纬度</div><div class="line">* <span class="doctag">@param</span> radia ？？</div><div class="line">* <span class="doctag">@param</span> callback 打卡异步回调</div><div class="line">* <span class="doctag">@return</span></div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hitCard</span><span class="params">(<span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, <span class="keyword">float</span> radia, hitCardCallback callback)</span></span>;</div></pre></td></tr></table></figure>
<p>获取距离参数更简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">freshDis</span><span class="params">(<span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, hitCardCallback callback)</span></span></div></pre></td></tr></table></figure>
<p>hitCard 方法中前两个参数能理解，radia 是什么鬼？<br>继续读代码发现定位使用的是 <a href="http://lbs.amap.com/api/android-sdk/summary/" target="_blank" rel="external">高德地图SDK</a>,  查询 SDK 得知 getAccuracy() 返回的是精度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HitCardActivity.<span class="keyword">this</span>.mLongitude = amapLocation.getLongitude() + BuildConfig.VERSION_NAME;</div><div class="line">HitCardActivity.<span class="keyword">this</span>.mLatitude = amapLocation.getLatitude() + BuildConfig.VERSION_NAME;</div><div class="line">HitCardActivity.<span class="keyword">this</span>.mRadia = amapLocation.getAccuracy() + BuildConfig.VERSION_NAME;</div></pre></td></tr></table></figure>
<p>好了，目标明确了，只需要 hook 高德地图的 getLongitude()， getLatitude() 和 getAccuracy() 三个方法即可。</p>
<p>目标是在一定精度范围内 (hook getAccuracy()) 返回一个经纬度坐标(hook getLongitude() &amp; getLatitude())。这个坐标需在阈值范围内才能有效。</p>
<h2 id="u76EE_u6807_u70B9_u5728_u54EA_u91CC_uFF1F"><a href="#u76EE_u6807_u70B9_u5728_u54EA_u91CC_uFF1F" class="headerlink" title="目标点在哪里？"></a>目标点在哪里？</h2><p>想到 GPS 定位的原理：根据立体几何知识，三维空间中，三个球体可以交于两个点，一个点远在外太空。另一个点落在地球上，就是我们的定位点了。</p>
<p>那么回到确定打卡目标点这个问题上。地图上的点可以看成是二位平面。即得出：</p>
<blockquote>
<p>两个圆交于两个点，其中一个点是目标点。</p>
</blockquote>
<p><img src="http://7xqi9q.com1.z0.glb.clouddn.com/2016-07-01_QQ20160701-0.png" alt="2016-07-01_QQ20160701-0.png"></p>
<p>接下来就是数学问题了：<br>在目标点附近取两个点 A(Xa, Ya) 和 B(Xb, Yb). 使用 Xposed hook 将 A、B 两点传递给服务器计算距离得到两个距离 La, Lb.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * replace getLongitude()</div><div class="line"> */</div><div class="line">findAndHookMethod(<span class="string">"com.amap.api.location.AMapLocation"</span>, loadPackageParam.classLoader, <span class="string">"getLongitude"</span>, <span class="keyword">new</span> XC_MethodReplacement() &#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> Object <span class="title">replaceHookedMethod</span><span class="params">(MethodHookParam methodHookParam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> randomLongitude(sourceLongitude);</div><div class="line">     &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * replace getLatitude()</div><div class="line"> */</div><div class="line">findAndHookMethod(<span class="string">"com.amap.api.location.AMapLocation"</span>, loadPackageParam.classLoader, <span class="string">"getLatitude"</span>, <span class="keyword">new</span> XC_MethodReplacement() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">replaceHookedMethod</span><span class="params">(MethodHookParam methodHookParam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> randomLatitude(sourceLatitude);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>对应的数学问题是：</p>
<blockquote>
<p>在二位坐标系上有两个圆<br>圆 A: 圆心坐标为 A(Xa, Ya), 半径为 La<br>圆 B: 圆心坐标为 B(Xa, Yb), 半径为 Lb<br>求这两个圆在二位坐标系上的交点坐标.</p>
</blockquote>
<p>根据下面规则将经纬度转化为“米”为单位的坐标系：</p>
<blockquote>
<p>在赤道上经度差1度对应的实际距离是111千米；<br>在经线上纬度差1度对应的实际距离是111千米；<br>在除赤道外的其他纬线上，经度差1度对应的实际距离是111*cos纬度。<br><img src="http://7xqi9q.com1.z0.glb.clouddn.com/2016-05-10-b8389b504fc2d56285606466e21190ef77c66cd4.jpg" alt="b8389b504fc2d56285606466e21190ef77c66cd4"></p>
</blockquote>
<p><em>解：</em></p>
<ul>
<li>1.首先确定圆的方程：<blockquote>
<p>(x-Xa)<sup>2</sup> + (y-Ya)<sup>2</sup> = La<sup>2</sup><br>(x-Xb)<sup>2</sup> + (y-Yb)<sup>2</sup> = Lb<sup>2</sup></p>
</blockquote>
</li>
<li>2.方程乡间, 销去二次项得到公共弦方程</li>
<li>3.代入法求出交点坐标。</li>
</ul>
<p>最终得出疑似目标点坐标 O(a, b). 依然使用 Xposed hook post 给服务器，这是后返回距离为2米。看来差不多了。</p>
<h2 id="u4EA7_u751F_u968F_u673A_u70B9"><a href="#u4EA7_u751F_u968F_u673A_u70B9" class="headerlink" title="产生随机点"></a>产生随机点</h2><p>现在要参照目的点在阈值范围内（50米）产生随机点：</p>
<p><img src="http://7xqi9q.com1.z0.glb.clouddn.com/2016-07-01_QQ20160701-1.png" alt="2016-07-01_QQ20160701-1.png"></p>
<p>以为有2米的误差，保险起见半径取45米，那么正方形的边长为 2*45/1.414 = 63.65.<br>那么在 O 点基础上加减 [0, 63.65/2) 区间里的随机数即可产生随机点，再按以上规则反向转换成经纬度 post 给服务器即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">randomLongitude</span><span class="params">(<span class="keyword">double</span> sourceLongitude)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(sourceLongitude + (<span class="keyword">new</span> Random(System.currentTimeMillis()).nextDouble() * <span class="number">0.000198</span>))</div><div class="line">        .setScale(<span class="number">6</span>, BigDecimal.ROUND_HALF_UP)</div><div class="line">        .doubleValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里整个过程就结束了，还有一些可有可无的 hook 就不再赘述了，过程差不多。例如: hook and replace getDeviceId 实现在任意 android device 打卡(原先是绑定设备的). hook after activity onResume() 方法初始化经纬度成员变量，解决地铁里等定位失败的地方不能触发定位onLocationChange callback 调用 getLongitude() 等方法完成 hook.</p>
<h2 id="OpenSource"><a href="#OpenSource" class="headerlink" title="OpenSource"></a>OpenSource</h2><p>完整代码: <a href="http://gitlab.jkyeo.com/jkyeo/fuck-checkin" target="_blank" rel="external">http://gitlab.jkyeo.com/jkyeo/fuck-checkin</a></p>
<h2 id="u7ED9_u5B9A_u4F4D_App__u5F00_u53D1_u7684_u4E00_u4E9B_u5EFA_u8BAE_uFF1A"><a href="#u7ED9_u5B9A_u4F4D_App__u5F00_u53D1_u7684_u4E00_u4E9B_u5EFA_u8BAE_uFF1A" class="headerlink" title="给定位 App 开发的一些建议："></a>给定位 App 开发的一些建议：</h2><p>基于 Xposed 框架的 hook 基本防不胜防。或许可以考虑其他更有效的方案，比如定位的同事必须连接公司 Wifi. 只有内部局域网才能打卡操作等等。</p>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>本文思路以及代码仅供技术交流, 学习参考使用, 切勿使用在真实环境中. Good good work, Day day up.<br>本人测试开发过程中发生的经纬度均以66结尾以便区分. 绝不会作弊打卡.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/05/17/《Android-源码设计模式解析与实战》学习笔记（一）/" class="prev">PREV</a><a href="/2016/04/18/BasicParamsInterceptor-为-OkHttp-请求添加公共参数/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'jkyeo';
var disqus_identifier = '2016/05/10/记一次-hook-基于地理位置打卡-App-的过程/';
var disqus_title = '记一次 hook 基于地理位置打卡 App 的过程';
var disqus_url = 'http://jkyeo.com/2016/05/10/记一次-hook-基于地理位置打卡-App-的过程/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//jkyeo.disqus.com/count.js" async></script><div class="copyright"><p>© 2016 - 2017 <a href="http://jkyeo.com">jk.yeo</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-64117634-2",'auto');ga('send','pageview');</script></body></html>